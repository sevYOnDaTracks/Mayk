{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, PLATFORM_ID, Directive, Injectable, Inject, EventEmitter, ElementRef, Component, ChangeDetectionStrategy, Input, Output, ContentChildren, ViewChild, ContentChild, HostBinding } from '@angular/core';\nimport { defer, shareReplay, Subject, map, takeUntil, fromEvent, Observable, timer, interval, merge, EMPTY } from 'rxjs';\nimport { takeUntil as takeUntil$1, switchMap, map as map$1, startWith, debounceTime, filter } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\nconst _c0 = [\"ngucarousel\"];\nconst _c1 = [\"nguItemsContainer\"];\nconst _c2 = [\"touchContainer\"];\nconst _c3 = [[[\"\", \"NguCarouselPrev\", \"\"]], [[\"\", \"NguCarouselNext\", \"\"]], [[\"\", \"NguCarouselPoint\", \"\"]]];\nconst _c4 = [\"[NguCarouselPrev]\", \"[NguCarouselNext]\", \"[NguCarouselPoint]\"];\nconst _c5 = [\"*\"];\nclass NguCarouselStore {\n  constructor(touch = new Touch(), vertical = new Vertical(), interval, transform = new Transfrom(), button, visibleItems, deviceType, type = 'fixed', token = '', items = 0, load = 0, deviceWidth = 0, carouselWidth = 0, itemWidth = 0, slideItems = 0, itemWidthPer = 0, itemLength = 0, currentSlide = 0, easing = 'cubic-bezier(0, 0, 0.2, 1)', speed = 200, loop = false, dexVal = 0, touchTransform = 0, isEnd = false, isFirst = true, isLast = false, RTL = false, point = true, velocity = 1) {\n    this.touch = touch;\n    this.vertical = vertical;\n    this.interval = interval;\n    this.transform = transform;\n    this.button = button;\n    this.visibleItems = visibleItems;\n    this.deviceType = deviceType;\n    this.type = type;\n    this.token = token;\n    this.items = items;\n    this.load = load;\n    this.deviceWidth = deviceWidth;\n    this.carouselWidth = carouselWidth;\n    this.itemWidth = itemWidth;\n    this.slideItems = slideItems;\n    this.itemWidthPer = itemWidthPer;\n    this.itemLength = itemLength;\n    this.currentSlide = currentSlide;\n    this.easing = easing;\n    this.speed = speed;\n    this.loop = loop;\n    this.dexVal = dexVal;\n    this.touchTransform = touchTransform;\n    this.isEnd = isEnd;\n    this.isFirst = isFirst;\n    this.isLast = isLast;\n    this.RTL = RTL;\n    this.point = point;\n    this.velocity = velocity;\n  }\n}\nclass ItemsControl {}\nclass Vertical {}\nclass NguButton {}\nclass Touch {}\n// This is misspelled. Must be changed to `Transform`.\nclass Transfrom {\n  constructor(xs = 0, sm = 0, md = 0, lg = 0, all = 0) {\n    this.xs = xs;\n    this.sm = sm;\n    this.md = md;\n    this.lg = lg;\n    this.all = all;\n    this.xl = 0;\n  }\n}\n/**\n * Default values\n * {sm: 768, md: 992, lg: 1200, xl: 1200}\n *\n * Bootstrap values:\n * {sm: 576, md: 768, lg: 992, xl: 1200}\n */\nclass Breakpoints {\n  constructor(sm = 768, md = 992, lg = 1200, xl = 1200) {\n    this.sm = sm;\n    this.md = md;\n    this.lg = lg;\n    this.xl = xl;\n  }\n}\nclass NguCarouselConfig {}\nclass NguCarouselOutletContext {\n  constructor(data) {\n    this.$implicit = data;\n  }\n}\nconst IS_BROWSER = new InjectionToken('IS_BROWSER', {\n  providedIn: 'root',\n  factory: () => isPlatformBrowser(inject(PLATFORM_ID))\n});\nlet NguCarouselItemDirective = /*#__PURE__*/(() => {\n  class NguCarouselItemDirective {\n    static #_ = this.ɵfac = function NguCarouselItemDirective_Factory(t) {\n      return new (t || NguCarouselItemDirective)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NguCarouselItemDirective,\n      selectors: [[\"\", \"NguCarouselItem\", \"\"]],\n      standalone: true\n    });\n  }\n  return NguCarouselItemDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselNextDirective = /*#__PURE__*/(() => {\n  class NguCarouselNextDirective {\n    static #_ = this.ɵfac = function NguCarouselNextDirective_Factory(t) {\n      return new (t || NguCarouselNextDirective)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NguCarouselNextDirective,\n      selectors: [[\"\", \"NguCarouselNext\", \"\"]],\n      standalone: true\n    });\n  }\n  return NguCarouselNextDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselPrevDirective = /*#__PURE__*/(() => {\n  class NguCarouselPrevDirective {\n    static #_ = this.ɵfac = function NguCarouselPrevDirective_Factory(t) {\n      return new (t || NguCarouselPrevDirective)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NguCarouselPrevDirective,\n      selectors: [[\"\", \"NguCarouselPrev\", \"\"]],\n      standalone: true\n    });\n  }\n  return NguCarouselPrevDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselPointDirective = /*#__PURE__*/(() => {\n  class NguCarouselPointDirective {\n    static #_ = this.ɵfac = function NguCarouselPointDirective_Factory(t) {\n      return new (t || NguCarouselPointDirective)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NguCarouselPointDirective,\n      selectors: [[\"\", \"NguCarouselPoint\", \"\"]],\n      standalone: true\n    });\n  }\n  return NguCarouselPointDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselDefDirective = /*#__PURE__*/(() => {\n  class NguCarouselDefDirective {\n    constructor(template) {\n      this.template = template;\n    }\n    static #_ = this.ɵfac = function NguCarouselDefDirective_Factory(t) {\n      return new (t || NguCarouselDefDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NguCarouselDefDirective,\n      selectors: [[\"\", \"nguCarouselDef\", \"\"]],\n      standalone: true\n    });\n  }\n  return NguCarouselDefDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselOutlet = /*#__PURE__*/(() => {\n  class NguCarouselOutlet {\n    constructor(viewContainer) {\n      this.viewContainer = viewContainer;\n    }\n    static #_ = this.ɵfac = function NguCarouselOutlet_Factory(t) {\n      return new (t || NguCarouselOutlet)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NguCarouselOutlet,\n      selectors: [[\"\", \"nguCarouselOutlet\", \"\"]],\n      standalone: true\n    });\n  }\n  return NguCarouselOutlet;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguHammerLoader = /*#__PURE__*/(() => {\n  class NguHammerLoader {\n    constructor() {\n      this._hammer$ = defer(() => import('hammerjs')).pipe(shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    load() {\n      return this._hammer$;\n    }\n    static #_ = this.ɵfac = function NguHammerLoader_Factory(t) {\n      return new (t || NguHammerLoader)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NguHammerLoader,\n      factory: NguHammerLoader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NguHammerLoader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselHammerManager = /*#__PURE__*/(() => {\n  class NguCarouselHammerManager {\n    constructor(_ngZone, _nguHammerLoader) {\n      this._ngZone = _ngZone;\n      this._nguHammerLoader = _nguHammerLoader;\n      this._destroy$ = new Subject();\n    }\n    ngOnDestroy() {\n      this._destroy$.next();\n    }\n    createHammer(element) {\n      return this._nguHammerLoader.load().pipe(map(() =>\n      // Note: The Hammer manager should be created outside of the Angular zone since it sets up\n      //       `pointermove` event listener which triggers change detection every time the pointer is moved.\n      this._ngZone.runOutsideAngular(() => new Hammer(element))),\n      // Note: the dynamic import is always a microtask which may run after the view is destroyed.\n      //       `takeUntil` is used to prevent setting Hammer up if the view had been destroyed before\n      //       the HammerJS is loaded.\n      takeUntil(this._destroy$));\n    }\n    on(hammer, event) {\n      return fromEvent(hammer, event).pipe(\n      // Note: We have to re-enter the Angular zone because Hammer would trigger events outside of the\n      //       Angular zone (since we set it up with `runOutsideAngular`).\n      enterNgZone(this._ngZone), takeUntil(this._destroy$));\n    }\n    static #_ = this.ɵfac = function NguCarouselHammerManager_Factory(t) {\n      return new (t || NguCarouselHammerManager)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(NguHammerLoader));\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NguCarouselHammerManager,\n      factory: NguCarouselHammerManager.ɵfac\n    });\n  }\n  return NguCarouselHammerManager;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction enterNgZone(ngZone) {\n  return source => new Observable(subscriber => source.subscribe({\n    next: value => ngZone.run(() => subscriber.next(value)),\n    error: error => ngZone.run(() => subscriber.error(error)),\n    complete: () => ngZone.run(() => subscriber.complete())\n  }));\n}\nlet NguWindowScrollListener = /*#__PURE__*/(() => {\n  class NguWindowScrollListener extends Subject {\n    constructor(isBrowser, ngZone) {\n      super();\n      this._destroy$ = new Subject();\n      // Note: this service is shared between multiple `NguCarousel` components and each instance\n      //       doesn't add new events listener for the `window`.\n      if (isBrowser) {\n        ngZone.runOutsideAngular(() => fromEvent(window, 'scroll').pipe(takeUntil$1(this._destroy$)).subscribe(this));\n      }\n    }\n    ngOnDestroy() {\n      this._destroy$.next();\n    }\n    static #_ = this.ɵfac = function NguWindowScrollListener_Factory(t) {\n      return new (t || NguWindowScrollListener)(i0.ɵɵinject(IS_BROWSER), i0.ɵɵinject(i0.NgZone));\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NguWindowScrollListener,\n      factory: NguWindowScrollListener.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NguWindowScrollListener;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\nlet NguCarousel = /*#__PURE__*/(() => {\n  class NguCarousel extends NguCarouselStore {\n    get dataSource() {\n      return this._dataSource;\n    }\n    set dataSource(data) {\n      if (data) {\n        this._switchDataSource(data);\n      }\n    }\n    /**\n     * The setter is used to catch the button if the button is wrapped with `ngIf`.\n     * https://github.com/uiuniversal/ngu-carousel/issues/91\n     */\n    set nextButton(nextButton) {\n      this._nextButton$.next(nextButton?.nativeElement);\n    }\n    /**\n     * The setter is used to catch the button if the button is wrapped with `ngIf`.\n     * https://github.com/uiuniversal/ngu-carousel/issues/91\n     */\n    set prevButton(prevButton) {\n      this._prevButton$.next(prevButton?.nativeElement);\n    }\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize Items operations by identifying a Items based on its data\n     * relative to the function to know if a Items should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    get trackBy() {\n      return this._trackByFn;\n    }\n    set trackBy(fn) {\n      if (NG_DEV_MODE && fn != null && typeof fn !== 'function' && console?.warn) {\n        console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this._trackByFn = fn;\n    }\n    constructor(_host, _renderer, _differs, _isBrowser, _cdr, _ngZone, _nguWindowScrollListener, _nguCarouselHammerManager) {\n      super();\n      this._host = _host;\n      this._renderer = _renderer;\n      this._differs = _differs;\n      this._isBrowser = _isBrowser;\n      this._cdr = _cdr;\n      this._ngZone = _ngZone;\n      this._nguWindowScrollListener = _nguWindowScrollListener;\n      this._nguCarouselHammerManager = _nguCarouselHammerManager;\n      /** Public property that may be accessed outside of the component. */\n      this.activePoint = 0;\n      /** Public property that may be accessed outside of the component. */\n      this.pointNumbers = [];\n      this.carouselLoad = new EventEmitter();\n      // eslint-disable-next-line @angular-eslint/no-output-on-prefix\n      this.onMove = new EventEmitter();\n      this._arrayChanges = null;\n      this._dataSource = null;\n      this._intervalController$ = new Subject();\n      this._hammer = null;\n      this._withAnimation = true;\n      this._destroy$ = new Subject();\n      this.ngu_dirty = true;\n      this._markedForCheck = false;\n      /** Subjects used to notify whenever buttons are removed or rendered so we can re-add listeners. */\n      this._prevButton$ = new Subject();\n      this._nextButton$ = new Subject();\n      this._setupButtonListeners();\n    }\n    ngDoCheck() {\n      this._checkChanges();\n    }\n    _checkChanges() {\n      if (this.ngu_dirty) {\n        this.ngu_dirty = false;\n        const dataStream = this._dataSource;\n        if (!this._arrayChanges && !!dataStream) {\n          this._dataDiffer = this._differs.find(dataStream).create((index, item) => this.trackBy ? this.trackBy(index, item) : item);\n        }\n      }\n      if (this._dataDiffer) {\n        this._arrayChanges = this._markedForCheck && this._arrayChanges ? this._arrayChanges : this._dataDiffer.diff(this._dataSource);\n        if (this._arrayChanges) {\n          this.renderNodeChanges(Array.from(this._dataSource));\n        }\n      }\n    }\n    _switchDataSource(dataSource) {\n      this._dataSource = dataSource;\n      this.ngu_dirty = true;\n    }\n    renderNodeChanges(data) {\n      if (!this._arrayChanges) return;\n      this.isLast = this._pointIndex === this.currentSlide;\n      const viewContainer = this._nodeOutlet.viewContainer;\n      this._markedForCheck = false;\n      this._arrayChanges.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n        const node = this._getNodeDef(data[currentIndex], currentIndex);\n        if (node?.template) {\n          if (item.previousIndex == null) {\n            const context = new NguCarouselOutletContext(data[currentIndex]);\n            context.index = currentIndex;\n            viewContainer.createEmbeddedView(node.template, context, currentIndex);\n          } else if (currentIndex == null) {\n            viewContainer.remove(adjustedPreviousIndex);\n          } else {\n            const view = viewContainer.get(adjustedPreviousIndex);\n            viewContainer.move(view, currentIndex);\n          }\n        }\n      });\n      this._updateItemIndexContext();\n      if (this._host.nativeElement) {\n        this._storeCarouselData();\n      }\n    }\n    /**\n     * Updates the index-related context for each row to reflect any changes in the index of the rows,\n     * e.g. first/last/even/odd.\n     */\n    _updateItemIndexContext() {\n      const viewContainer = this._nodeOutlet.viewContainer;\n      for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\n        const viewRef = viewContainer.get(renderIndex);\n        const context = viewRef.context;\n        context.count = count;\n        context.first = renderIndex === 0;\n        context.last = renderIndex === count - 1;\n        context.even = renderIndex % 2 === 0;\n        context.odd = !context.even;\n        context.index = renderIndex;\n      }\n    }\n    _getNodeDef(data, i) {\n      if (this._defDirectives?.length === 1) {\n        return this._defDirectives.first;\n      }\n      const nodeDef = (this._defDirectives || []).find(def => !!def.when?.(i, data));\n      return nodeDef;\n    }\n    ngAfterViewInit() {\n      this._inputValidation();\n      this._carouselCssNode = this._createStyleElem();\n      if (this._isBrowser) {\n        this._carouselInterval();\n        if (!this.vertical.enabled && this.inputs.touch) {\n          this._setupHammer();\n        }\n        this._setupWindowResizeListener();\n        this._onWindowScrolling();\n      }\n    }\n    ngAfterContentInit() {\n      this._cdr.markForCheck();\n      this._defDirectives.changes.subscribe(() => {\n        this._markedForCheck = true;\n        this._checkChanges();\n      });\n      this._defDirectives.notifyOnChanges();\n    }\n    _inputValidation() {\n      this.inputs.gridBreakpoints = this.inputs.gridBreakpoints ? this.inputs.gridBreakpoints : new Breakpoints();\n      if (this.inputs.grid.xl === undefined) {\n        this.inputs.grid.xl = this.inputs.grid.lg;\n      }\n      this.type = this.inputs.grid.all !== 0 ? 'fixed' : 'responsive';\n      this.loop = this.inputs.loop || false;\n      this.inputs.easing = this.inputs.easing || 'cubic-bezier(0, 0, 0.2, 1)';\n      this.touch.active = this.inputs.touch || false;\n      this.RTL = this.inputs.RTL ? true : false;\n      this.interval = this.inputs.interval || undefined;\n      this.velocity = typeof this.inputs.velocity === 'number' ? this.inputs.velocity : this.velocity;\n      if (this.inputs.vertical && this.inputs.vertical.enabled) {\n        this.vertical.enabled = this.inputs.vertical.enabled;\n        this.vertical.height = this.inputs.vertical.height;\n      }\n      this._directionSymbol = this.RTL ? '' : '-';\n      this.point = this.inputs.point && typeof this.inputs.point.visible !== 'undefined' ? this.inputs.point.visible : true;\n      this._carouselSize();\n    }\n    ngOnDestroy() {\n      this._hammer?.destroy();\n      this._destroy$.next();\n    }\n    /** Get Touch input */\n    _setupHammer() {\n      // Note: doesn't need to unsubscribe because streams are piped with `takeUntil` already.\n      this._nguCarouselHammerManager.createHammer(this._touchContainer.nativeElement).subscribe(hammer => {\n        this._hammer = hammer;\n        hammer.get('pan').set({\n          direction: Hammer.DIRECTION_HORIZONTAL\n        });\n        this._nguCarouselHammerManager.on(hammer, 'panstart').subscribe(() => {\n          this.carouselWidth = this._nguItemsContainer.nativeElement.offsetWidth;\n          this.touchTransform = this.transform[this.deviceType];\n          this.dexVal = 0;\n          this._setStyle(this._nguItemsContainer.nativeElement, 'transition', '');\n        });\n        if (this.vertical.enabled) {\n          this._nguCarouselHammerManager.on(hammer, 'panup').subscribe(ev => {\n            this._touchHandling('panleft', ev);\n          });\n          this._nguCarouselHammerManager.on(hammer, 'pandown').subscribe(ev => {\n            this._touchHandling('panright', ev);\n          });\n        } else {\n          this._nguCarouselHammerManager.on(hammer, 'panleft').subscribe(ev => {\n            this._touchHandling('panleft', ev);\n          });\n          this._nguCarouselHammerManager.on(hammer, 'panright').subscribe(ev => {\n            this._touchHandling('panright', ev);\n          });\n        }\n        this._nguCarouselHammerManager.on(hammer, 'panend pancancel').subscribe(({\n          velocity\n        }) => {\n          if (Math.abs(velocity) >= this.velocity) {\n            this.touch.velocity = velocity;\n            let direc = 0;\n            if (!this.RTL) {\n              direc = this.touch.swipe === 'panright' ? 0 : 1;\n            } else {\n              direc = this.touch.swipe === 'panright' ? 1 : 0;\n            }\n            this._carouselScrollOne(direc);\n          } else {\n            this.dexVal = 0;\n            this._setStyle(this._nguItemsContainer.nativeElement, 'transition', 'transform 324ms cubic-bezier(0, 0, 0.2, 1)');\n            this._setStyle(this._nguItemsContainer.nativeElement, 'transform', '');\n          }\n        });\n        this._nguCarouselHammerManager.on(hammer, 'hammer.input').subscribe(({\n          srcEvent\n        }) => {\n          // allow nested touch events to no propagate, this may have other side affects but works for now.\n          // TODO: It is probably better to check the source element of the event and only apply the handle to the correct carousel\n          srcEvent.stopPropagation();\n        });\n      });\n    }\n    /** handle touch input */\n    _touchHandling(e, ev) {\n      // vertical touch events seem to cause to panstart event with an odd delta\n      // and a center of {x:0,y:0} so this will ignore them\n      if (ev.center.x === 0) {\n        return;\n      }\n      ev = Math.abs(this.vertical.enabled ? ev.deltaY : ev.deltaX);\n      let valt = ev - this.dexVal;\n      valt = this.type === 'responsive' ? Math.abs(ev - this.dexVal) / (this.vertical.enabled ? this.vertical.height : this.carouselWidth) * 100 : valt;\n      this.dexVal = ev;\n      this.touch.swipe = e;\n      this._setTouchTransfrom(e, valt);\n      this._setTransformFromTouch();\n    }\n    _setTouchTransfrom(e, valt) {\n      const condition = this.RTL ? 'panright' : 'panleft';\n      this.touchTransform = e === condition ? valt + this.touchTransform : this.touchTransform - valt;\n    }\n    _setTransformFromTouch() {\n      if (this.touchTransform < 0) {\n        this.touchTransform = 0;\n      }\n      const type = this.type === 'responsive' ? '%' : 'px';\n      this._setStyle(this._nguItemsContainer.nativeElement, 'transform', this.vertical.enabled ? `translate3d(0, ${this._directionSymbol}${this.touchTransform}${type}, 0)` : `translate3d(${this._directionSymbol}${this.touchTransform}${type}, 0, 0)`);\n    }\n    /** this fn used to disable the interval when it is not on the viewport */\n    _onWindowScrolling() {\n      const {\n        offsetTop,\n        offsetHeight\n      } = this._host.nativeElement;\n      const {\n        scrollY: windowScrollY,\n        innerHeight: windowInnerHeight\n      } = window;\n      const isCarouselOnScreen = offsetTop <= windowScrollY + windowInnerHeight - offsetHeight / 4 && offsetHeight + offsetHeight / 2 >= windowScrollY;\n      if (isCarouselOnScreen) {\n        this._intervalController$.next(1);\n      } else {\n        this._intervalController$.next(0);\n      }\n    }\n    /** store data based on width of the screen for the carousel */\n    _storeCarouselData() {\n      const breakpoints = this.inputs.gridBreakpoints;\n      this.deviceWidth = this._isBrowser ? window.innerWidth : breakpoints?.xl;\n      this.carouselWidth = this.carouselMain1.nativeElement.offsetWidth;\n      if (this.type === 'responsive') {\n        this.deviceType = this.deviceWidth >= breakpoints?.xl ? 'xl' : this.deviceWidth >= breakpoints?.lg ? 'lg' : this.deviceWidth >= breakpoints?.md ? 'md' : this.deviceWidth >= breakpoints?.sm ? 'sm' : 'xs';\n        this.items = this.inputs.grid[this.deviceType];\n        this.itemWidth = this.carouselWidth / this.items;\n      } else {\n        this.items = Math.trunc(this.carouselWidth / this.inputs.grid.all);\n        this.itemWidth = this.inputs.grid.all;\n        this.deviceType = 'all';\n      }\n      this.slideItems = +(this.inputs.slide < this.items ? this.inputs.slide : this.items);\n      this.load = this.inputs.load >= this.slideItems ? this.inputs.load : this.slideItems;\n      this.speed = this.inputs.speed && this.inputs.speed > -1 ? this.inputs.speed : 400;\n      this._carouselPoint();\n    }\n    /** Used to reset the carousel */\n    reset(withoutAnimation) {\n      withoutAnimation && (this._withAnimation = false);\n      this._carouselCssNode.textContent = '';\n      this.moveTo(0);\n      this._carouselPoint();\n    }\n    /** Init carousel point */\n    _carouselPoint() {\n      const Nos = Array.from(this._dataSource).length - (this.items - this.slideItems);\n      this._pointIndex = Math.ceil(Nos / this.slideItems);\n      const pointers = [];\n      if (this._pointIndex > 1 || !this.inputs.point?.hideOnSingleSlide) {\n        for (let i = 0; i < this._pointIndex; i++) {\n          pointers.push(i);\n        }\n      }\n      this.pointNumbers = pointers;\n      this._carouselPointActiver();\n      if (this._pointIndex <= 1) {\n        this._btnBoolean(1, 1);\n      } else {\n        if (this.currentSlide === 0 && !this.loop) {\n          this._btnBoolean(1, 0);\n        } else {\n          this._btnBoolean(0, 0);\n        }\n      }\n    }\n    /** change the active point in carousel */\n    _carouselPointActiver() {\n      const i = Math.ceil(this.currentSlide / this.slideItems);\n      this.activePoint = i;\n      this._cdr.markForCheck();\n    }\n    /** this function is used to scoll the carousel when point is clicked */\n    moveTo(slide, withoutAnimation) {\n      // slide = slide - 1;\n      withoutAnimation && (this._withAnimation = false);\n      if (this.activePoint !== slide && slide < this._pointIndex) {\n        let slideremains;\n        const btns = this.currentSlide < slide ? 1 : 0;\n        switch (slide) {\n          case 0:\n            this._btnBoolean(1, 0);\n            slideremains = slide * this.slideItems;\n            break;\n          case this._pointIndex - 1:\n            this._btnBoolean(0, 1);\n            slideremains = Array.from(this._dataSource).length - this.items;\n            break;\n          default:\n            this._btnBoolean(0, 0);\n            slideremains = slide * this.slideItems;\n        }\n        this._carouselScrollTwo(btns, slideremains, this.speed);\n      }\n    }\n    /** set the style of the carousel based the inputs data */\n    _carouselSize() {\n      this.token = this._generateID();\n      let dism = '';\n      this._styleid = `.${this.token} > .ngucarousel > .ngu-touch-container > .ngucarousel-items`;\n      if (this.inputs.custom === 'banner') {\n        this._renderer.addClass(this._host.nativeElement, 'banner');\n      }\n      if (this.inputs.animation === 'lazy') {\n        dism += `${this._styleid} > .item {transition: transform .6s ease;}`;\n      }\n      const breakpoints = this.inputs.gridBreakpoints;\n      let itemStyle = '';\n      if (this.vertical.enabled) {\n        const itemWidthXS = `${this._styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.xs}px}`;\n        const itemWidthSM = `${this._styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.sm}px}`;\n        const itemWidthMD = `${this._styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.md}px}`;\n        const itemWidthLG = `${this._styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.lg}px}`;\n        const itemWidthXL = `${this._styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.xl}px}`;\n        itemStyle = `@media (max-width:${breakpoints?.sm - 1}px){${itemWidthXS}}\n                    @media (max-width:${breakpoints?.sm}px){${itemWidthSM}}\n                    @media (min-width:${breakpoints?.md}px){${itemWidthMD}}\n                    @media (min-width:${breakpoints?.lg}px){${itemWidthLG}}\n                    @media (min-width:${breakpoints?.xl}px){${itemWidthXL}}`;\n      } else if (this.type === 'responsive') {\n        const itemWidthXS = this.inputs.type === 'mobile' ? `${this._styleid} .item {flex: 0 0 ${95 / +this.inputs.grid.xs}%; width: ${95 / +this.inputs.grid.xs}%;}` : `${this._styleid} .item {flex: 0 0 ${100 / +this.inputs.grid.xs}%; width: ${100 / +this.inputs.grid.xs}%;}`;\n        const itemWidthSM = `${this._styleid} > .item {flex: 0 0 ${100 / +this.inputs.grid.sm}%; width: ${100 / +this.inputs.grid.sm}%}`;\n        const itemWidthMD = `${this._styleid} > .item {flex: 0 0 ${100 / +this.inputs.grid.md}%; width: ${100 / +this.inputs.grid.md}%}`;\n        const itemWidthLG = `${this._styleid} > .item {flex: 0 0 ${100 / +this.inputs.grid.lg}%; width: ${100 / +this.inputs.grid.lg}%}`;\n        const itemWidthXL = `${this._styleid} > .item {flex: 0 0 ${100 / +this.inputs.grid.xl}%; width: ${100 / +this.inputs.grid.xl}%}`;\n        itemStyle = `@media (max-width:${breakpoints?.sm - 1}px){${itemWidthXS}}\n                    @media (min-width:${breakpoints?.sm}px){${itemWidthSM}}\n                    @media (min-width:${breakpoints?.md}px){${itemWidthMD}}\n                    @media (min-width:${breakpoints?.lg}px){${itemWidthLG}}\n                    @media (min-width:${breakpoints?.xl}px){${itemWidthXL}}`;\n      } else {\n        itemStyle = `${this._styleid} .item {flex: 0 0 ${this.inputs.grid.all}px; width: ${this.inputs.grid.all}px;}`;\n      }\n      this._renderer.addClass(this._host.nativeElement, this.token);\n      if (this.vertical.enabled) {\n        this._renderer.addClass(this._nguItemsContainer.nativeElement, 'nguvertical');\n        this._renderer.setStyle(this.carouselMain1.nativeElement, 'height', `${this.vertical.height}px`);\n      }\n      this.RTL && !this.vertical.enabled && this._renderer.addClass(this._host.nativeElement, 'ngurtl');\n      this._createStyleElem(`${dism} ${itemStyle}`);\n      this._storeCarouselData();\n    }\n    /** logic to scroll the carousel step 1 */\n    _carouselScrollOne(Btn) {\n      let itemSpeed = this.speed;\n      let currentSlide = 0;\n      let touchMove = Math.ceil(this.dexVal / this.itemWidth);\n      touchMove = isFinite(touchMove) ? touchMove : 0;\n      this._setStyle(this._nguItemsContainer.nativeElement, 'transform', '');\n      if (this._pointIndex === 1) {\n        return;\n      } else if (Btn === 0 && (!this.loop && !this.isFirst || this.loop)) {\n        const currentSlideD = this.currentSlide - this.slideItems;\n        const MoveSlide = currentSlideD + this.slideItems;\n        this._btnBoolean(0, 1);\n        if (this.currentSlide === 0) {\n          currentSlide = Array.from(this._dataSource).length - this.items;\n          itemSpeed = 400;\n          this._btnBoolean(0, 1);\n        } else if (this.slideItems >= MoveSlide) {\n          currentSlide = 0;\n          this._btnBoolean(1, 0);\n        } else {\n          this._btnBoolean(0, 0);\n          if (touchMove > this.slideItems) {\n            currentSlide = this.currentSlide - touchMove;\n            itemSpeed = 200;\n          } else {\n            currentSlide = this.currentSlide - this.slideItems;\n          }\n        }\n        this._carouselScrollTwo(Btn, currentSlide, itemSpeed);\n      } else if (Btn === 1 && (!this.loop && !this.isLast || this.loop)) {\n        if (Array.from(this._dataSource).length <= this.currentSlide + this.items + this.slideItems && !this.isLast) {\n          currentSlide = Array.from(this._dataSource).length - this.items;\n          this._btnBoolean(0, 1);\n        } else if (this.isLast) {\n          currentSlide = 0;\n          itemSpeed = 400;\n          this._btnBoolean(1, 0);\n        } else {\n          this._btnBoolean(0, 0);\n          if (touchMove > this.slideItems) {\n            currentSlide = this.currentSlide + this.slideItems + (touchMove - this.slideItems);\n            itemSpeed = 200;\n          } else {\n            currentSlide = this.currentSlide + this.slideItems;\n          }\n        }\n        this._carouselScrollTwo(Btn, currentSlide, itemSpeed);\n      }\n    }\n    /** logic to scroll the carousel step 2 */\n    _carouselScrollTwo(Btn, currentSlide, itemSpeed) {\n      if (this.dexVal !== 0) {\n        const val = Math.abs(this.touch.velocity);\n        let somt = Math.floor(this.dexVal / val / this.dexVal * (this.deviceWidth - this.dexVal));\n        somt = somt > itemSpeed ? itemSpeed : somt;\n        itemSpeed = somt < 200 ? 200 : somt;\n        this.dexVal = 0;\n      }\n      if (this._withAnimation) {\n        this._setStyle(this._nguItemsContainer.nativeElement, 'transition', `transform ${itemSpeed}ms ${this.inputs.easing}`);\n        this.inputs.animation && this._carouselAnimator(Btn, currentSlide + 1, currentSlide + this.items, itemSpeed, Math.abs(this.currentSlide - currentSlide));\n      } else {\n        this._setStyle(this._nguItemsContainer.nativeElement, 'transition', ``);\n      }\n      this.itemLength = Array.from(this._dataSource).length;\n      this._transformStyle(currentSlide);\n      this.currentSlide = currentSlide;\n      this.onMove.emit(this);\n      this._carouselPointActiver();\n      this._carouselLoadTrigger();\n      this._withAnimation = true;\n    }\n    /** boolean function for making isFirst and isLast */\n    _btnBoolean(first, last) {\n      this.isFirst = !!first;\n      this.isLast = !!last;\n    }\n    _transformString(grid, slide) {\n      let collect = '';\n      collect += `${this._styleid} { transform: translate3d(`;\n      if (this.vertical.enabled) {\n        this.transform[grid] = this.vertical.height / this.inputs.grid[grid] * slide;\n        collect += `0, -${this.transform[grid]}px, 0`;\n      } else {\n        this.transform[grid] = 100 / this.inputs.grid[grid] * slide;\n        collect += `${this._directionSymbol}${this.transform[grid]}%, 0, 0`;\n      }\n      collect += `); }`;\n      return collect;\n    }\n    /** set the transform style to scroll the carousel  */\n    _transformStyle(slide) {\n      let slideCss = '';\n      if (this.type === 'responsive') {\n        const breakpoints = this.inputs.gridBreakpoints;\n        slideCss = `@media (max-width: ${breakpoints?.sm - 1}px) {${this._transformString('xs', slide)}}\n      @media (min-width: ${breakpoints?.sm}px) {${this._transformString('sm', slide)} }\n      @media (min-width: ${breakpoints?.md}px) {${this._transformString('md', slide)} }\n      @media (min-width: ${breakpoints?.lg}px) {${this._transformString('lg', slide)} }\n      @media (min-width: ${breakpoints?.xl}px) {${this._transformString('xl', slide)} }`;\n      } else {\n        this.transform.all = this.inputs.grid.all * slide;\n        slideCss = `${this._styleid} { transform: translate3d(${this._directionSymbol}${this.transform.all}px, 0, 0);`;\n      }\n      this._carouselCssNode.textContent = slideCss;\n    }\n    /** this will trigger the carousel to load the items */\n    _carouselLoadTrigger() {\n      if (typeof this.inputs.load === 'number') {\n        Array.from(this._dataSource).length - this.load <= this.currentSlide + this.items && this.carouselLoad.emit(this.currentSlide);\n      }\n    }\n    /** generate Class for each carousel to set specific style */\n    _generateID() {\n      let text = '';\n      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n      for (let i = 0; i < 6; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n      }\n      return `ngucarousel${text}`;\n    }\n    /** handle the auto slide */\n    _carouselInterval() {\n      const container = this.carouselMain1.nativeElement;\n      if (this.interval && this.loop) {\n        this._nguWindowScrollListener.pipe(\n        // Note: do not use `debounceTime` since it may flush queued actions within the Angular zone.\n        switchMap(() => timer(600)), takeUntil$1(this._destroy$)).subscribe(() => {\n          // Note: we don't run change detection on each `scroll` event, but we re-enter the\n          //       Angular zone once the DOM timer fires to be backwards compatible.\n          //       TODO: revisit later since we may not run change detection at all on this task.\n          this._ngZone.run(() => this._onWindowScrolling());\n        });\n        const mapToZero = map$1(() => 0);\n        const mapToOne = map$1(() => 1);\n        const play$ = fromEvent(container, 'mouseleave').pipe(mapToOne);\n        const pause$ = fromEvent(container, 'mouseenter').pipe(mapToZero);\n        const touchPlay$ = fromEvent(container, 'touchstart').pipe(mapToOne);\n        const touchPause$ = fromEvent(container, 'touchend').pipe(mapToZero);\n        const interval$ = interval(this.inputs.interval?.timing).pipe(mapToOne);\n        const initialDelay = this.interval.initialDelay || 0;\n        const carouselInterval$ = merge(play$, touchPlay$, pause$, touchPause$, this._intervalController$).pipe(startWith(1), switchMap(val => {\n          this._cdr.markForCheck();\n          return val ? interval$ : EMPTY;\n        }));\n        timer(initialDelay).pipe(switchMap(() => carouselInterval$), takeUntil$1(this._destroy$)).subscribe(() => {\n          this._carouselScrollOne(1);\n        });\n      }\n    }\n    /** animate the carousel items */\n    _carouselAnimator(direction, start, end, speed, length) {\n      const viewContainer = this._nodeOutlet.viewContainer;\n      let val = length < 5 ? length : 5;\n      val = val === 1 ? 3 : val;\n      const collectedIndexes = [];\n      if (direction === 1) {\n        for (let i = start - 1; i < end; i++) {\n          collectedIndexes.push(i);\n          val = val * 2;\n          const viewRef = viewContainer.get(i);\n          const context = viewRef.context;\n          context.animate = {\n            value: true,\n            params: {\n              distance: val\n            }\n          };\n        }\n      } else {\n        for (let i = end - 1; i >= start - 1; i--) {\n          collectedIndexes.push(i);\n          val = val * 2;\n          const viewRef = viewContainer.get(i);\n          const context = viewRef.context;\n          context.animate = {\n            value: true,\n            params: {\n              distance: -val\n            }\n          };\n        }\n      }\n      this._cdr.markForCheck();\n      timer(speed * 0.7).pipe(takeUntil$1(this._destroy$)).subscribe(() => this._removeAnimations(collectedIndexes));\n    }\n    _removeAnimations(collectedIndexes) {\n      const viewContainer = this._nodeOutlet.viewContainer;\n      collectedIndexes.forEach(i => {\n        const viewRef = viewContainer.get(i);\n        const context = viewRef.context;\n        context.animate = {\n          value: false,\n          params: {\n            distance: 0\n          }\n        };\n      });\n      this._cdr.markForCheck();\n    }\n    /** Short form for setElementStyle */\n    _setStyle(el, prop, val) {\n      this._renderer.setStyle(el, prop, val);\n    }\n    /** For generating style tag */\n    _createStyleElem(datas) {\n      const styleItem = this._renderer.createElement('style');\n      if (datas) {\n        const styleText = this._renderer.createText(datas);\n        this._renderer.appendChild(styleItem, styleText);\n      }\n      this._renderer.appendChild(this._host.nativeElement, styleItem);\n      return styleItem;\n    }\n    _setupButtonListeners() {\n      this._prevButton$.pipe(\n      // Returning `EMPTY` will remove event listener once the button is removed from the DOM.\n      switchMap(prevButton => prevButton ? fromEvent(prevButton, 'click') : EMPTY), takeUntil$1(this._destroy$)).subscribe(() => this._carouselScrollOne(0));\n      this._nextButton$.pipe(switchMap(nextButton => nextButton ? fromEvent(nextButton, 'click') : EMPTY), takeUntil$1(this._destroy$)).subscribe(() => this._carouselScrollOne(1));\n    }\n    _setupWindowResizeListener() {\n      this._ngZone.runOutsideAngular(() => fromEvent(window, 'resize').pipe(debounceTime(500), filter(() => this.deviceWidth !== window.outerWidth), takeUntil$1(this._destroy$)).subscribe(() => {\n        this._setStyle(this._nguItemsContainer.nativeElement, 'transition', ``);\n        // Re-enter the Angular zone only after `resize` events have been dispatched\n        // and the timer has run (in `debounceTime`).\n        this._ngZone.run(() => {\n          this._storeCarouselData();\n          this._cdr.markForCheck();\n        });\n      }));\n    }\n    static #_ = this.ɵfac = function NguCarousel_Factory(t) {\n      return new (t || NguCarousel)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(IS_BROWSER), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(NguWindowScrollListener), i0.ɵɵdirectiveInject(NguCarouselHammerManager));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NguCarousel,\n      selectors: [[\"ngu-carousel\"]],\n      contentQueries: function NguCarousel_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NguCarouselNextDirective, 5, ElementRef);\n          i0.ɵɵcontentQuery(dirIndex, NguCarouselPrevDirective, 5, ElementRef);\n          i0.ɵɵcontentQuery(dirIndex, NguCarouselDefDirective, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextButton = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prevButton = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._defDirectives = _t);\n        }\n      },\n      viewQuery: function NguCarousel_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(NguCarouselOutlet, 7);\n          i0.ɵɵviewQuery(_c0, 7, ElementRef);\n          i0.ɵɵviewQuery(_c1, 7, ElementRef);\n          i0.ɵɵviewQuery(_c2, 7, ElementRef);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.carouselMain1 = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nguItemsContainer = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._touchContainer = _t.first);\n        }\n      },\n      inputs: {\n        inputs: \"inputs\",\n        dataSource: \"dataSource\",\n        trackBy: \"trackBy\"\n      },\n      outputs: {\n        carouselLoad: \"carouselLoad\",\n        onMove: \"onMove\"\n      },\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([NguCarouselHammerManager]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c4,\n      decls: 11,\n      vars: 0,\n      consts: [[\"ngucarousel\", \"\"], [\"touchContainer\", \"\"], [\"nguItemsContainer\", \"\"], [1, \"ngucarousel\"], [1, \"ngu-touch-container\"], [1, \"ngucarousel-items\"], [\"nguCarouselOutlet\", \"\"], [1, \"nguclearFix\"]],\n      template: function NguCarousel_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c3);\n          i0.ɵɵelementStart(0, \"div\", 3, 0);\n          i0.ɵɵprojection(2);\n          i0.ɵɵelementStart(3, \"div\", 4, 1)(5, \"div\", 5, 2);\n          i0.ɵɵelementContainer(7, 6);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelement(8, \"div\", 7);\n          i0.ɵɵprojection(9, 1);\n          i0.ɵɵelementEnd();\n          i0.ɵɵprojection(10, 2);\n        }\n      },\n      dependencies: [NguCarouselOutlet],\n      styles: [\"[_nghost-%COMP%]{display:block;position:relative}.ngurtl[_nghost-%COMP%]{direction:rtl}.ngucarousel[_ngcontent-%COMP%]{position:relative;overflow:hidden;height:100%}.ngucarousel[_ngcontent-%COMP%]   .ngucarousel-items[_ngcontent-%COMP%]{position:relative;display:flex;height:100%}.nguvertical[_ngcontent-%COMP%]{flex-direction:column}.banner[_ngcontent-%COMP%]   .ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]{position:absolute;width:100%;bottom:20px}.banner[_ngcontent-%COMP%]   .ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{background:rgba(255,255,255,.55)}.banner[_ngcontent-%COMP%]   .ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li.active[_ngcontent-%COMP%]{background:white}.banner[_ngcontent-%COMP%]   .ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:hover{cursor:pointer}.ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]{list-style-type:none;text-align:center;padding:12px;margin:0;white-space:nowrap;overflow:auto;box-sizing:border-box}.ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{display:inline-block;border-radius:50%;background:rgba(0,0,0,.55);padding:4px;margin:0 4px;transition-timing-function:cubic-bezier(.17,.67,.83,.67);transition:.4s}.ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li.active[_ngcontent-%COMP%]{background:#6b6b6b;transform:scale(1.8)}.ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:hover{cursor:pointer}.nguclearFix[_ngcontent-%COMP%]{clear:both}\"],\n      changeDetection: 0\n    });\n  }\n  return NguCarousel;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguItemComponent = /*#__PURE__*/(() => {\n  class NguItemComponent {\n    constructor() {\n      this.classes = true;\n    }\n    static #_ = this.ɵfac = function NguItemComponent_Factory(t) {\n      return new (t || NguItemComponent)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NguItemComponent,\n      selectors: [[\"ngu-item\"]],\n      hostVars: 2,\n      hostBindings: function NguItemComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"item\", ctx.classes);\n        }\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c5,\n      decls: 1,\n      vars: 0,\n      template: function NguItemComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2\n    });\n  }\n  return NguItemComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguTileComponent = /*#__PURE__*/(() => {\n  class NguTileComponent {\n    constructor() {\n      this.classes = true;\n    }\n    static #_ = this.ɵfac = function NguTileComponent_Factory(t) {\n      return new (t || NguTileComponent)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NguTileComponent,\n      selectors: [[\"ngu-tile\"]],\n      hostVars: 2,\n      hostBindings: function NguTileComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"item\", ctx.classes);\n        }\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c5,\n      decls: 2,\n      vars: 0,\n      consts: [[1, \"tile\"]],\n      template: function NguTileComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵprojection(1);\n          i0.ɵɵelementEnd();\n        }\n      },\n      styles: [\"[_nghost-%COMP%]{padding:10px;box-sizing:border-box}.tile[_ngcontent-%COMP%]{box-shadow:0 2px 5px #00000029,0 2px 10px #0000001f}\"]\n    });\n  }\n  return NguTileComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of carousel\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NguCarousel, NguCarouselConfig, NguCarouselDefDirective, NguCarouselItemDirective, NguCarouselNextDirective, NguCarouselOutlet, NguCarouselPointDirective, NguCarouselPrevDirective, NguCarouselStore, NguItemComponent, NguTileComponent };\n//# sourceMappingURL=ngu-carousel.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}