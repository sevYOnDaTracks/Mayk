{"ast":null,"code":"import { isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Directive, EventEmitter, isDevMode, PLATFORM_ID, ElementRef, Component, ChangeDetectionStrategy, Inject, Input, Output, ContentChildren, ViewChild, ContentChild, HostBinding, NgModule } from '@angular/core';\nimport { Subject, Observable, of, fromEvent, interval, merge, EMPTY } from 'rxjs';\nimport { takeUntil, mapTo, startWith, switchMap } from 'rxjs/operators';\nconst _c0 = [\"ngucarousel\"];\nconst _c1 = [\"nguItemsContainer\"];\nconst _c2 = [\"touchContainer\"];\nconst _c3 = [[[\"\", \"NguCarouselPrev\", \"\"]], [[\"\", \"NguCarouselNext\", \"\"]], [[\"\", \"NguCarouselPoint\", \"\"]]];\nconst _c4 = [\"[NguCarouselPrev]\", \"[NguCarouselNext]\", \"[NguCarouselPoint]\"];\nconst _c5 = [\"*\"];\nclass NguCarouselStore {\n  constructor(touch = new Touch(), vertical = new Vertical(), interval, transform = new Transfrom(), button, visibleItems, deviceType, type = 'fixed', token = '', items = 0, load = 0, deviceWidth = 0, carouselWidth = 0, itemWidth = 0, slideItems = 0, itemWidthPer = 0, itemLength = 0, currentSlide = 0, easing = 'cubic-bezier(0, 0, 0.2, 1)', speed = 200, loop = false, dexVal = 0, touchTransform = 0, isEnd = false, isFirst = true, isLast = false, RTL = false, point = true, velocity = 1) {\n    this.touch = touch;\n    this.vertical = vertical;\n    this.interval = interval;\n    this.transform = transform;\n    this.button = button;\n    this.visibleItems = visibleItems;\n    this.deviceType = deviceType;\n    this.type = type;\n    this.token = token;\n    this.items = items;\n    this.load = load;\n    this.deviceWidth = deviceWidth;\n    this.carouselWidth = carouselWidth;\n    this.itemWidth = itemWidth;\n    this.slideItems = slideItems;\n    this.itemWidthPer = itemWidthPer;\n    this.itemLength = itemLength;\n    this.currentSlide = currentSlide;\n    this.easing = easing;\n    this.speed = speed;\n    this.loop = loop;\n    this.dexVal = dexVal;\n    this.touchTransform = touchTransform;\n    this.isEnd = isEnd;\n    this.isFirst = isFirst;\n    this.isLast = isLast;\n    this.RTL = RTL;\n    this.point = point;\n    this.velocity = velocity;\n  }\n}\nclass ItemsControl {}\nclass Vertical {}\nclass NguButton {}\nclass Touch {}\nclass Transfrom {\n  constructor(xs = 0, sm = 0, md = 0, lg = 0, all = 0) {\n    this.xs = xs;\n    this.sm = sm;\n    this.md = md;\n    this.lg = lg;\n    this.all = all;\n    this.xl = 0;\n  }\n}\n/**\n * Default values\n * {sm: 768, md: 992, lg: 1200, xl: 1200}\n *\n * Bootstrap values:\n * {sm: 576, md: 768, lg: 992, xl: 1200}\n */\nclass Breakpoints {\n  constructor(sm = 768, md = 992, lg = 1200, xl = 1200) {\n    this.sm = sm;\n    this.md = md;\n    this.lg = lg;\n    this.xl = xl;\n  }\n}\nclass NguCarouselConfig {}\nclass NguCarouselOutletContext {\n  constructor(data) {\n    this.$implicit = data;\n  }\n}\nlet NguCarouselItemDirective = /*#__PURE__*/(() => {\n  class NguCarouselItemDirective {}\n  NguCarouselItemDirective.ɵfac = function NguCarouselItemDirective_Factory(t) {\n    return new (t || NguCarouselItemDirective)();\n  };\n  NguCarouselItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NguCarouselItemDirective,\n    selectors: [[\"\", \"NguCarouselItem\", \"\"]]\n  });\n  return NguCarouselItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselNextDirective = /*#__PURE__*/(() => {\n  class NguCarouselNextDirective {}\n  NguCarouselNextDirective.ɵfac = function NguCarouselNextDirective_Factory(t) {\n    return new (t || NguCarouselNextDirective)();\n  };\n  NguCarouselNextDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NguCarouselNextDirective,\n    selectors: [[\"\", \"NguCarouselNext\", \"\"]]\n  });\n  return NguCarouselNextDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselPrevDirective = /*#__PURE__*/(() => {\n  class NguCarouselPrevDirective {}\n  NguCarouselPrevDirective.ɵfac = function NguCarouselPrevDirective_Factory(t) {\n    return new (t || NguCarouselPrevDirective)();\n  };\n  NguCarouselPrevDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NguCarouselPrevDirective,\n    selectors: [[\"\", \"NguCarouselPrev\", \"\"]]\n  });\n  return NguCarouselPrevDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselPointDirective = /*#__PURE__*/(() => {\n  class NguCarouselPointDirective {}\n  NguCarouselPointDirective.ɵfac = function NguCarouselPointDirective_Factory(t) {\n    return new (t || NguCarouselPointDirective)();\n  };\n  NguCarouselPointDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NguCarouselPointDirective,\n    selectors: [[\"\", \"NguCarouselPoint\", \"\"]]\n  });\n  return NguCarouselPointDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselDefDirective = /*#__PURE__*/(() => {\n  class NguCarouselDefDirective {\n    constructor(template) {\n      this.template = template;\n    }\n  }\n  NguCarouselDefDirective.ɵfac = function NguCarouselDefDirective_Factory(t) {\n    return new (t || NguCarouselDefDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  NguCarouselDefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NguCarouselDefDirective,\n    selectors: [[\"\", \"nguCarouselDef\", \"\"]]\n  });\n  return NguCarouselDefDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nlet NguCarouselOutlet = /*#__PURE__*/(() => {\n  class NguCarouselOutlet {\n    constructor(viewContainer) {\n      this.viewContainer = viewContainer;\n    }\n  }\n  NguCarouselOutlet.ɵfac = function NguCarouselOutlet_Factory(t) {\n    return new (t || NguCarouselOutlet)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  NguCarouselOutlet.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NguCarouselOutlet,\n    selectors: [[\"\", \"nguCarouselOutlet\", \"\"]]\n  });\n  return NguCarouselOutlet;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// @dynamic\n// @dynamic\n// eslint-disable-next-line @angular-eslint/component-class-suffix\nlet NguCarousel = /*#__PURE__*/(() => {\n  class NguCarousel extends NguCarouselStore {\n    constructor(_el, _renderer, _differs, platformId, cdr) {\n      super();\n      this._el = _el;\n      this._renderer = _renderer;\n      this._differs = _differs;\n      this.platformId = platformId;\n      this.cdr = cdr;\n      this.withAnim = true;\n      this.isHovered = false;\n      this.carouselLoad = new EventEmitter();\n      // eslint-disable-next-line @angular-eslint/no-output-on-prefix\n      this.onMove = new EventEmitter();\n      this._intervalController$ = new Subject();\n      this.pointNumbers = [];\n    }\n    get dataSource() {\n      return this._dataSource;\n    }\n    set dataSource(data) {\n      if (data) {\n        this._switchDataSource(data);\n      }\n    }\n    /** The setter is used to catch the button if the button has ngIf\n     * issue id #91\n     */\n    set nextBtn(btn) {\n      this.listener2?.();\n      if (btn) {\n        this.listener2 = this._renderer.listen(btn.nativeElement, 'click', () => this._carouselScrollOne(1));\n      }\n    }\n    /** The setter is used to catch the button if the button has ngIf\n     * issue id #91\n     */\n    set prevBtn(btn) {\n      this.listener1?.();\n      if (btn) {\n        this.listener1 = this._renderer.listen(btn.nativeElement, 'click', () => this._carouselScrollOne(0));\n      }\n    }\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize Items operations by identifying a Items based on its data\n     * relative to the function to know if a Items should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    get trackBy() {\n      return this._trackByFn;\n    }\n    set trackBy(fn) {\n      if (isDevMode() && fn != null && typeof fn !== 'function' && console && console.warn) {\n        console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\n      }\n      this._trackByFn = fn;\n    }\n    ngOnInit() {\n      this._dataDiffer = this._differs.find([]).create((_i, item) => {\n        return this.trackBy ? this.trackBy(_i, item) : item;\n      });\n    }\n    ngDoCheck() {\n      this.arrayChanges = this._dataDiffer.diff(this.dataSource);\n      if (this.arrayChanges && this._defDirec) {\n        this._observeRenderChanges();\n      }\n    }\n    _switchDataSource(dataSource) {\n      this._dataSource = dataSource;\n      if (this._defDirec) {\n        this._observeRenderChanges();\n      }\n    }\n    _observeRenderChanges() {\n      let dataStream;\n      if (this._dataSource instanceof Observable) {\n        dataStream = this._dataSource;\n      } else if (Array.isArray(this._dataSource)) {\n        dataStream = of(this._dataSource);\n      }\n      if (dataStream) {\n        this._dataSubscription = dataStream.pipe(takeUntil(this._intervalController$)).subscribe(data => {\n          this.renderNodeChanges(data);\n          this.isLast = this.pointIndex === this.currentSlide;\n        });\n      }\n    }\n    renderNodeChanges(data, viewContainer = this._nodeOutlet.viewContainer) {\n      if (!this.arrayChanges) return;\n      this.arrayChanges.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n        const node = this._getNodeDef(data[currentIndex], currentIndex);\n        if (item.previousIndex == null) {\n          const context = new NguCarouselOutletContext(data[currentIndex]);\n          context.index = currentIndex;\n          viewContainer.createEmbeddedView(node.template, context, currentIndex);\n        } else if (currentIndex == null) {\n          viewContainer.remove(adjustedPreviousIndex);\n        } else {\n          const view = viewContainer.get(adjustedPreviousIndex);\n          viewContainer.move(view, currentIndex);\n        }\n      });\n      this._updateItemIndexContext();\n      if (this.carousel) {\n        this._storeCarouselData();\n      }\n    }\n    /**\n     * Updates the index-related context for each row to reflect any changes in the index of the rows,\n     * e.g. first/last/even/odd.\n     */\n    _updateItemIndexContext() {\n      const viewContainer = this._nodeOutlet.viewContainer;\n      for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\n        const viewRef = viewContainer.get(renderIndex);\n        const context = viewRef.context;\n        context.count = count;\n        context.first = renderIndex === 0;\n        context.last = renderIndex === count - 1;\n        context.even = renderIndex % 2 === 0;\n        context.odd = !context.even;\n        context.index = renderIndex;\n      }\n    }\n    _getNodeDef(data, i) {\n      if (this._defDirec.length === 1) {\n        return this._defDirec.first;\n      }\n      const nodeDef = this._defDirec.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n      return nodeDef;\n    }\n    ngAfterViewInit() {\n      this.carousel = this._el.nativeElement;\n      this._inputValidation();\n      this.carouselCssNode = this._createStyleElem();\n      if (isPlatformBrowser(this.platformId)) {\n        this._carouselInterval();\n        if (!this.vertical.enabled) {\n          this._touch();\n        }\n        this.listener3 = this._renderer.listen('window', 'resize', event => {\n          this._onResizing(event);\n        });\n        this._onWindowScrolling();\n      }\n    }\n    ngAfterContentInit() {\n      this._observeRenderChanges();\n      this.cdr.markForCheck();\n    }\n    _inputValidation() {\n      this.inputs.gridBreakpoints = this.inputs.gridBreakpoints ? this.inputs.gridBreakpoints : new Breakpoints();\n      if (this.inputs.grid.xl === undefined) {\n        this.inputs.grid.xl = this.inputs.grid.lg;\n      }\n      this.type = this.inputs.grid.all !== 0 ? 'fixed' : 'responsive';\n      this.loop = this.inputs.loop || false;\n      this.inputs.easing = this.inputs.easing || 'cubic-bezier(0, 0, 0.2, 1)';\n      this.touch.active = this.inputs.touch || false;\n      this.RTL = this.inputs.RTL ? true : false;\n      this.interval = this.inputs.interval || undefined;\n      this.velocity = typeof this.inputs.velocity === 'number' ? this.inputs.velocity : this.velocity;\n      if (this.inputs.vertical && this.inputs.vertical.enabled) {\n        this.vertical.enabled = this.inputs.vertical.enabled;\n        this.vertical.height = this.inputs.vertical.height;\n      }\n      this.directionSym = this.RTL ? '' : '-';\n      this.point = this.inputs.point && typeof this.inputs.point.visible !== 'undefined' ? this.inputs.point.visible : true;\n      this._carouselSize();\n    }\n    ngOnDestroy() {\n      this.carouselInt && this.carouselInt.unsubscribe();\n      this._intervalController$.unsubscribe();\n      this.carouselLoad.complete();\n      this.onMove.complete();\n      /** remove listeners */\n      clearTimeout(this.onScrolling);\n      for (let i = 1; i <= 4; i++) {\n        const str = `listener${i}`;\n        this[str] && this[str]();\n      }\n    }\n    _onResizing(event) {\n      clearTimeout(this.onResize);\n      this.onResize = setTimeout(() => {\n        if (this.deviceWidth !== event.target.outerWidth) {\n          this._setStyle(this.nguItemsContainer.nativeElement, 'transition', ``);\n          this._storeCarouselData();\n        }\n      }, 500);\n    }\n    /** Get Touch input */\n    _touch() {\n      if (this.inputs.touch) {\n        import('hammerjs').then(() => {\n          const hammertime = new Hammer(this.touchContainer.nativeElement);\n          hammertime.get('pan').set({\n            direction: Hammer.DIRECTION_HORIZONTAL\n          });\n          hammertime.on('panstart', ev => {\n            this.carouselWidth = this.nguItemsContainer.nativeElement.offsetWidth;\n            this.touchTransform = this.transform[this.deviceType];\n            this.dexVal = 0;\n            this._setStyle(this.nguItemsContainer.nativeElement, 'transition', '');\n          });\n          if (this.vertical.enabled) {\n            hammertime.on('panup', ev => {\n              this._touchHandling('panleft', ev);\n            });\n            hammertime.on('pandown', ev => {\n              this._touchHandling('panright', ev);\n            });\n          } else {\n            hammertime.on('panleft', ev => {\n              this._touchHandling('panleft', ev);\n            });\n            hammertime.on('panright', ev => {\n              this._touchHandling('panright', ev);\n            });\n          }\n          hammertime.on('panend pancancel', ev => {\n            if (Math.abs(ev.velocity) >= this.velocity) {\n              this.touch.velocity = ev.velocity;\n              let direc = 0;\n              if (!this.RTL) {\n                direc = this.touch.swipe === 'panright' ? 0 : 1;\n              } else {\n                direc = this.touch.swipe === 'panright' ? 1 : 0;\n              }\n              this._carouselScrollOne(direc);\n            } else {\n              this.dexVal = 0;\n              this._setStyle(this.nguItemsContainer.nativeElement, 'transition', 'transform 324ms cubic-bezier(0, 0, 0.2, 1)');\n              this._setStyle(this.nguItemsContainer.nativeElement, 'transform', '');\n            }\n          });\n          hammertime.on('hammer.input', ev => {\n            // allow nested touch events to no propagate, this may have other side affects but works for now.\n            // TODO: It is probably better to check the source element of the event and only apply the handle to the correct carousel\n            ev.srcEvent.stopPropagation();\n          });\n        });\n      }\n    }\n    /** handle touch input */\n    _touchHandling(e, ev) {\n      // vertical touch events seem to cause to panstart event with an odd delta\n      // and a center of {x:0,y:0} so this will ignore them\n      if (ev.center.x === 0) {\n        return;\n      }\n      ev = Math.abs(this.vertical.enabled ? ev.deltaY : ev.deltaX);\n      let valt = ev - this.dexVal;\n      valt = this.type === 'responsive' ? Math.abs(ev - this.dexVal) / (this.vertical.enabled ? this.vertical.height : this.carouselWidth) * 100 : valt;\n      this.dexVal = ev;\n      this.touch.swipe = e;\n      this._setTouchTransfrom(e, valt);\n      this._setTransformFromTouch();\n    }\n    _setTouchTransfrom(e, valt) {\n      const condition = this.RTL ? 'panright' : 'panleft';\n      this.touchTransform = e === condition ? valt + this.touchTransform : this.touchTransform - valt;\n    }\n    _setTransformFromTouch() {\n      if (this.touchTransform < 0) {\n        this.touchTransform = 0;\n      }\n      const type = this.type === 'responsive' ? '%' : 'px';\n      this._setStyle(this.nguItemsContainer.nativeElement, 'transform', this.vertical.enabled ? `translate3d(0, ${this.directionSym}${this.touchTransform}${type}, 0)` : `translate3d(${this.directionSym}${this.touchTransform}${type}, 0, 0)`);\n    }\n    /** this fn used to disable the interval when it is not on the viewport */\n    _onWindowScrolling() {\n      const top = this.carousel.offsetTop;\n      const scrollY = window.scrollY;\n      const heightt = window.innerHeight;\n      const carouselHeight = this.carousel.offsetHeight;\n      const isCarouselOnScreen = top <= scrollY + heightt - carouselHeight / 4 && top + carouselHeight / 2 >= scrollY;\n      if (isCarouselOnScreen) {\n        this._intervalController$.next(1);\n      } else {\n        this._intervalController$.next(0);\n      }\n    }\n    /** store data based on width of the screen for the carousel */\n    _storeCarouselData() {\n      const breakpoints = this.inputs.gridBreakpoints;\n      this.deviceWidth = isPlatformBrowser(this.platformId) ? window.innerWidth : breakpoints?.xl;\n      this.carouselWidth = this.carouselMain1.nativeElement.offsetWidth;\n      if (this.type === 'responsive') {\n        this.deviceType = this.deviceWidth >= breakpoints?.xl ? 'xl' : this.deviceWidth >= breakpoints?.lg ? 'lg' : this.deviceWidth >= breakpoints?.md ? 'md' : this.deviceWidth >= breakpoints?.sm ? 'sm' : 'xs';\n        this.items = this.inputs.grid[this.deviceType];\n        this.itemWidth = this.carouselWidth / this.items;\n      } else {\n        this.items = Math.trunc(this.carouselWidth / this.inputs.grid.all);\n        this.itemWidth = this.inputs.grid.all;\n        this.deviceType = 'all';\n      }\n      this.slideItems = +(this.inputs.slide < this.items ? this.inputs.slide : this.items);\n      this.load = this.inputs.load >= this.slideItems ? this.inputs.load : this.slideItems;\n      this.speed = this.inputs.speed && this.inputs.speed > -1 ? this.inputs.speed : 400;\n      this._carouselPoint();\n    }\n    /** Used to reset the carousel */\n    reset(withOutAnimation) {\n      withOutAnimation && (this.withAnim = false);\n      this.carouselCssNode.textContent = '';\n      this.moveTo(0);\n      this._carouselPoint();\n    }\n    /** Init carousel point */\n    _carouselPoint() {\n      const Nos = this.dataSource.length - (this.items - this.slideItems);\n      this.pointIndex = Math.ceil(Nos / this.slideItems);\n      const pointers = [];\n      if (this.pointIndex > 1 || !this.inputs.point?.hideOnSingleSlide) {\n        for (let i = 0; i < this.pointIndex; i++) {\n          pointers.push(i);\n        }\n      }\n      this.pointNumbers = pointers;\n      this._carouselPointActiver();\n      if (this.pointIndex <= 1) {\n        this._btnBoolean(1, 1);\n      } else {\n        if (this.currentSlide === 0 && !this.loop) {\n          this._btnBoolean(1, 0);\n        } else {\n          this._btnBoolean(0, 0);\n        }\n      }\n    }\n    /** change the active point in carousel */\n    _carouselPointActiver() {\n      const i = Math.ceil(this.currentSlide / this.slideItems);\n      this.activePoint = i;\n      this.cdr.markForCheck();\n    }\n    /** this function is used to scoll the carousel when point is clicked */\n    moveTo(slide, withOutAnimation) {\n      // slide = slide - 1;\n      withOutAnimation && (this.withAnim = false);\n      if (this.activePoint !== slide && slide < this.pointIndex) {\n        let slideremains;\n        const btns = this.currentSlide < slide ? 1 : 0;\n        switch (slide) {\n          case 0:\n            this._btnBoolean(1, 0);\n            slideremains = slide * this.slideItems;\n            break;\n          case this.pointIndex - 1:\n            this._btnBoolean(0, 1);\n            slideremains = this.dataSource.length - this.items;\n            break;\n          default:\n            this._btnBoolean(0, 0);\n            slideremains = slide * this.slideItems;\n        }\n        this._carouselScrollTwo(btns, slideremains, this.speed);\n      }\n    }\n    /** set the style of the carousel based the inputs data */\n    _carouselSize() {\n      this.token = this._generateID();\n      let dism = '';\n      this.styleid = `.${this.token} > .ngucarousel > .ngu-touch-container > .ngucarousel-items`;\n      if (this.inputs.custom === 'banner') {\n        this._renderer.addClass(this.carousel, 'banner');\n      }\n      if (this.inputs.animation === 'lazy') {\n        dism += `${this.styleid} > .item {transition: transform .6s ease;}`;\n      }\n      const breakpoints = this.inputs.gridBreakpoints;\n      let itemStyle = '';\n      if (this.vertical.enabled) {\n        const itemWidthXS = `${this.styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.xs}px}`;\n        const itemWidthSM = `${this.styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.sm}px}`;\n        const itemWidthMD = `${this.styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.md}px}`;\n        const itemWidthLG = `${this.styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.lg}px}`;\n        const itemWidthXL = `${this.styleid} > .item {height: ${this.vertical.height / +this.inputs.grid.xl}px}`;\n        itemStyle = `@media (max-width:${breakpoints?.sm - 1}px){${itemWidthXS}}\n                    @media (max-width:${breakpoints?.sm}px){${itemWidthSM}}\n                    @media (min-width:${breakpoints?.md}px){${itemWidthMD}}\n                    @media (min-width:${breakpoints?.lg}px){${itemWidthLG}}\n                    @media (min-width:${breakpoints?.xl}px){${itemWidthXL}}`;\n      } else if (this.type === 'responsive') {\n        const itemWidthXS = this.inputs.type === 'mobile' ? `${this.styleid} .item {flex: 0 0 ${95 / +this.inputs.grid.xs}%; width: ${95 / +this.inputs.grid.xs}%;}` : `${this.styleid} .item {flex: 0 0 ${100 / +this.inputs.grid.xs}%; width: ${100 / +this.inputs.grid.xs}%;}`;\n        const itemWidthSM = `${this.styleid} > .item {flex: 0 0 ${100 / +this.inputs.grid.sm}%; width: ${100 / +this.inputs.grid.sm}%}`;\n        const itemWidthMD = `${this.styleid} > .item {flex: 0 0 ${100 / +this.inputs.grid.md}%; width: ${100 / +this.inputs.grid.md}%}`;\n        const itemWidthLG = `${this.styleid} > .item {flex: 0 0 ${100 / +this.inputs.grid.lg}%; width: ${100 / +this.inputs.grid.lg}%}`;\n        const itemWidthXL = `${this.styleid} > .item {flex: 0 0 ${100 / +this.inputs.grid.xl}%; width: ${100 / +this.inputs.grid.xl}%}`;\n        itemStyle = `@media (max-width:${breakpoints?.sm - 1}px){${itemWidthXS}}\n                    @media (min-width:${breakpoints?.sm}px){${itemWidthSM}}\n                    @media (min-width:${breakpoints?.md}px){${itemWidthMD}}\n                    @media (min-width:${breakpoints?.lg}px){${itemWidthLG}}\n                    @media (min-width:${breakpoints?.xl}px){${itemWidthXL}}`;\n      } else {\n        itemStyle = `${this.styleid} .item {flex: 0 0 ${this.inputs.grid.all}px; width: ${this.inputs.grid.all}px;}`;\n      }\n      this._renderer.addClass(this.carousel, this.token);\n      if (this.vertical.enabled) {\n        this._renderer.addClass(this.nguItemsContainer.nativeElement, 'nguvertical');\n        this._renderer.setStyle(this.carouselMain1.nativeElement, 'height', `${this.vertical.height}px`);\n      }\n      // tslint:disable-next-line:no-unused-expression\n      this.RTL && !this.vertical.enabled && this._renderer.addClass(this.carousel, 'ngurtl');\n      this._createStyleElem(`${dism} ${itemStyle}`);\n      this._storeCarouselData();\n    }\n    /** logic to scroll the carousel step 1 */\n    _carouselScrollOne(Btn) {\n      let itemSpeed = this.speed;\n      let translateXval = 0;\n      let currentSlide = 0;\n      let touchMove = Math.ceil(this.dexVal / this.itemWidth);\n      touchMove = isFinite(touchMove) ? touchMove : 0;\n      this._setStyle(this.nguItemsContainer.nativeElement, 'transform', '');\n      if (this.pointIndex === 1) {\n        return;\n      } else if (Btn === 0 && (!this.loop && !this.isFirst || this.loop)) {\n        const currentSlideD = this.currentSlide - this.slideItems;\n        const MoveSlide = currentSlideD + this.slideItems;\n        this._btnBoolean(0, 1);\n        if (this.currentSlide === 0) {\n          currentSlide = this.dataSource.length - this.items;\n          itemSpeed = 400;\n          this._btnBoolean(0, 1);\n        } else if (this.slideItems >= MoveSlide) {\n          currentSlide = translateXval = 0;\n          this._btnBoolean(1, 0);\n        } else {\n          this._btnBoolean(0, 0);\n          if (touchMove > this.slideItems) {\n            currentSlide = this.currentSlide - touchMove;\n            itemSpeed = 200;\n          } else {\n            currentSlide = this.currentSlide - this.slideItems;\n          }\n        }\n        this._carouselScrollTwo(Btn, currentSlide, itemSpeed);\n      } else if (Btn === 1 && (!this.loop && !this.isLast || this.loop)) {\n        if (this.dataSource.length <= this.currentSlide + this.items + this.slideItems && !this.isLast) {\n          currentSlide = this.dataSource.length - this.items;\n          this._btnBoolean(0, 1);\n        } else if (this.isLast) {\n          currentSlide = translateXval = 0;\n          itemSpeed = 400;\n          this._btnBoolean(1, 0);\n        } else {\n          this._btnBoolean(0, 0);\n          if (touchMove > this.slideItems) {\n            currentSlide = this.currentSlide + this.slideItems + (touchMove - this.slideItems);\n            itemSpeed = 200;\n          } else {\n            currentSlide = this.currentSlide + this.slideItems;\n          }\n        }\n        this._carouselScrollTwo(Btn, currentSlide, itemSpeed);\n      }\n    }\n    /** logic to scroll the carousel step 2 */\n    _carouselScrollTwo(Btn, currentSlide, itemSpeed) {\n      // tslint:disable-next-line:no-unused-expression\n      if (this.dexVal !== 0) {\n        const val = Math.abs(this.touch.velocity);\n        let somt = Math.floor(this.dexVal / val / this.dexVal * (this.deviceWidth - this.dexVal));\n        somt = somt > itemSpeed ? itemSpeed : somt;\n        itemSpeed = somt < 200 ? 200 : somt;\n        this.dexVal = 0;\n      }\n      if (this.withAnim) {\n        this._setStyle(this.nguItemsContainer.nativeElement, 'transition', `transform ${itemSpeed}ms ${this.inputs.easing}`);\n        this.inputs.animation && this._carouselAnimator(Btn, currentSlide + 1, currentSlide + this.items, itemSpeed, Math.abs(this.currentSlide - currentSlide));\n      } else {\n        this._setStyle(this.nguItemsContainer.nativeElement, 'transition', ``);\n      }\n      this.itemLength = this.dataSource.length;\n      this._transformStyle(currentSlide);\n      this.currentSlide = currentSlide;\n      this.onMove.emit(this);\n      this._carouselPointActiver();\n      this._carouselLoadTrigger();\n      this.withAnim = true;\n    }\n    /** boolean function for making isFirst and isLast */\n    _btnBoolean(first, last) {\n      this.isFirst = !!first;\n      this.isLast = !!last;\n    }\n    _transformString(grid, slide) {\n      let collect = '';\n      collect += `${this.styleid} { transform: translate3d(`;\n      if (this.vertical.enabled) {\n        this.transform[grid] = this.vertical.height / this.inputs.grid[grid] * slide;\n        collect += `0, -${this.transform[grid]}px, 0`;\n      } else {\n        this.transform[grid] = 100 / this.inputs.grid[grid] * slide;\n        collect += `${this.directionSym}${this.transform[grid]}%, 0, 0`;\n      }\n      collect += `); }`;\n      return collect;\n    }\n    /** set the transform style to scroll the carousel  */\n    _transformStyle(slide) {\n      let slideCss = '';\n      if (this.type === 'responsive') {\n        const breakpoints = this.inputs.gridBreakpoints;\n        slideCss = `@media (max-width: ${breakpoints?.sm - 1}px) {${this._transformString('xs', slide)}}\n      @media (min-width: ${breakpoints?.sm}px) {${this._transformString('sm', slide)} }\n      @media (min-width: ${breakpoints?.md}px) {${this._transformString('md', slide)} }\n      @media (min-width: ${breakpoints?.lg}px) {${this._transformString('lg', slide)} }\n      @media (min-width: ${breakpoints?.xl}px) {${this._transformString('xl', slide)} }`;\n      } else {\n        this.transform.all = this.inputs.grid.all * slide;\n        slideCss = `${this.styleid} { transform: translate3d(${this.directionSym}${this.transform.all}px, 0, 0);`;\n      }\n      this.carouselCssNode.textContent = slideCss;\n    }\n    /** this will trigger the carousel to load the items */\n    _carouselLoadTrigger() {\n      if (typeof this.inputs.load === 'number') {\n        this.dataSource.length - this.load <= this.currentSlide + this.items && this.carouselLoad.emit(this.currentSlide);\n      }\n    }\n    /** generate Class for each carousel to set specific style */\n    _generateID() {\n      let text = '';\n      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n      for (let i = 0; i < 6; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n      }\n      return `ngucarousel${text}`;\n    }\n    /** handle the auto slide */\n    _carouselInterval() {\n      const container = this.carouselMain1.nativeElement;\n      if (this.interval && this.loop) {\n        this.listener4 = this._renderer.listen('window', 'scroll', () => {\n          clearTimeout(this.onScrolling);\n          this.onScrolling = setTimeout(() => {\n            this._onWindowScrolling();\n          }, 600);\n        });\n        const play$ = fromEvent(container, 'mouseleave').pipe(mapTo(1));\n        const pause$ = fromEvent(container, 'mouseenter').pipe(mapTo(0));\n        const touchPlay$ = fromEvent(container, 'touchstart').pipe(mapTo(1));\n        const touchPause$ = fromEvent(container, 'touchend').pipe(mapTo(0));\n        const interval$ = interval(this.inputs.interval?.timing).pipe(mapTo(1));\n        setTimeout(() => {\n          this.carouselInt = merge(play$, touchPlay$, pause$, touchPause$, this._intervalController$).pipe(startWith(1), switchMap(val => {\n            this.isHovered = !val;\n            this.cdr.markForCheck();\n            return val ? interval$ : EMPTY;\n          })).subscribe(res => {\n            this._carouselScrollOne(1);\n          });\n        }, this.interval.initialDelay);\n      }\n    }\n    _updateItemIndexContextAni() {\n      const viewContainer = this._nodeOutlet.viewContainer;\n      for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\n        const viewRef = viewContainer.get(renderIndex);\n        const context = viewRef.context;\n        context.count = count;\n        context.first = renderIndex === 0;\n        context.last = renderIndex === count - 1;\n        context.even = renderIndex % 2 === 0;\n        context.odd = !context.even;\n        context.index = renderIndex;\n      }\n    }\n    /** animate the carousel items */\n    _carouselAnimator(direction, start, end, speed, length, viewContainer = this._nodeOutlet.viewContainer) {\n      let val = length < 5 ? length : 5;\n      val = val === 1 ? 3 : val;\n      const collectIndex = [];\n      if (direction === 1) {\n        for (let i = start - 1; i < end; i++) {\n          collectIndex.push(i);\n          val = val * 2;\n          const viewRef = viewContainer.get(i);\n          const context = viewRef.context;\n          context.animate = {\n            value: true,\n            params: {\n              distance: val\n            }\n          };\n        }\n      } else {\n        for (let i = end - 1; i >= start - 1; i--) {\n          collectIndex.push(i);\n          val = val * 2;\n          const viewRef = viewContainer.get(i);\n          const context = viewRef.context;\n          context.animate = {\n            value: true,\n            params: {\n              distance: -val\n            }\n          };\n        }\n      }\n      this.cdr.markForCheck();\n      setTimeout(() => {\n        this._removeAnimations(collectIndex);\n      }, speed * 0.7);\n    }\n    _removeAnimations(indexs) {\n      const viewContainer = this._nodeOutlet.viewContainer;\n      indexs.forEach(i => {\n        const viewRef = viewContainer.get(i);\n        const context = viewRef.context;\n        context.animate = {\n          value: false,\n          params: {\n            distance: 0\n          }\n        };\n      });\n      this.cdr.markForCheck();\n    }\n    /** Short form for setElementStyle */\n    _setStyle(el, prop, val) {\n      this._renderer.setStyle(el, prop, val);\n    }\n    /** For generating style tag */\n    _createStyleElem(datas) {\n      const styleItem = this._renderer.createElement('style');\n      if (datas) {\n        const styleText = this._renderer.createText(datas);\n        this._renderer.appendChild(styleItem, styleText);\n      }\n      this._renderer.appendChild(this.carousel, styleItem);\n      return styleItem;\n    }\n  }\n  NguCarousel.ɵfac = function NguCarousel_Factory(t) {\n    return new (t || NguCarousel)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  NguCarousel.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NguCarousel,\n    selectors: [[\"ngu-carousel\"]],\n    contentQueries: function NguCarousel_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NguCarouselNextDirective, 5, ElementRef);\n        i0.ɵɵcontentQuery(dirIndex, NguCarouselPrevDirective, 5, ElementRef);\n        i0.ɵɵcontentQuery(dirIndex, NguCarouselDefDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextBtn = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prevBtn = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._defDirec = _t);\n      }\n    },\n    viewQuery: function NguCarousel_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(NguCarouselOutlet, 7);\n        i0.ɵɵviewQuery(_c0, 7, ElementRef);\n        i0.ɵɵviewQuery(_c1, 7, ElementRef);\n        i0.ɵɵviewQuery(_c2, 7, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.carouselMain1 = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nguItemsContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.touchContainer = _t.first);\n      }\n    },\n    inputs: {\n      inputs: \"inputs\",\n      dataSource: \"dataSource\",\n      trackBy: \"trackBy\"\n    },\n    outputs: {\n      carouselLoad: \"carouselLoad\",\n      onMove: \"onMove\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c4,\n    decls: 11,\n    vars: 0,\n    consts: [[1, \"ngucarousel\"], [\"ngucarousel\", \"\"], [1, \"ngu-touch-container\"], [\"touchContainer\", \"\"], [1, \"ngucarousel-items\"], [\"nguItemsContainer\", \"\"], [\"nguCarouselOutlet\", \"\"], [1, \"nguclearFix\"]],\n    template: function NguCarousel_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c3);\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementStart(3, \"div\", 2, 3)(5, \"div\", 4, 5);\n        i0.ɵɵelementContainer(7, 6);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelement(8, \"div\", 7);\n        i0.ɵɵprojection(9, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(10, 2);\n      }\n    },\n    dependencies: [NguCarouselOutlet],\n    styles: [\"[_nghost-%COMP%]{display:block;position:relative}.ngurtl[_nghost-%COMP%]{direction:rtl}.ngucarousel[_ngcontent-%COMP%]{position:relative;overflow:hidden;height:100%}.ngucarousel[_ngcontent-%COMP%]   .ngucarousel-items[_ngcontent-%COMP%]{position:relative;display:flex;height:100%}.nguvertical[_ngcontent-%COMP%]{flex-direction:column}.banner[_ngcontent-%COMP%]   .ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]{position:absolute;width:100%;bottom:20px}.banner[_ngcontent-%COMP%]   .ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{background:rgba(255,255,255,.55)}.banner[_ngcontent-%COMP%]   .ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li.active[_ngcontent-%COMP%]{background:white}.banner[_ngcontent-%COMP%]   .ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:hover{cursor:pointer}.ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]{list-style-type:none;text-align:center;padding:12px;margin:0;white-space:nowrap;overflow:auto;box-sizing:border-box}.ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{display:inline-block;border-radius:50%;background:rgba(0,0,0,.55);padding:4px;margin:0 4px;transition-timing-function:cubic-bezier(.17,.67,.83,.67);transition:.4s}.ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li.active[_ngcontent-%COMP%]{background:#6b6b6b;transform:scale(1.8)}.ngucarouselPointDefault[_ngcontent-%COMP%]   .ngucarouselPoint[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]:hover{cursor:pointer}.nguclearFix[_ngcontent-%COMP%]{clear:both}\"],\n    changeDetection: 0\n  });\n  return NguCarousel;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguItemComponent = /*#__PURE__*/(() => {\n  class NguItemComponent {\n    constructor() {\n      this.classes = true;\n    }\n  }\n  NguItemComponent.ɵfac = function NguItemComponent_Factory(t) {\n    return new (t || NguItemComponent)();\n  };\n  NguItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NguItemComponent,\n    selectors: [[\"ngu-item\"]],\n    hostVars: 2,\n    hostBindings: function NguItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"item\", ctx.classes);\n      }\n    },\n    ngContentSelectors: _c5,\n    decls: 1,\n    vars: 0,\n    template: function NguItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    }\n  });\n  return NguItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguTileComponent = /*#__PURE__*/(() => {\n  class NguTileComponent {\n    constructor() {\n      this.classes = true;\n    }\n  }\n  NguTileComponent.ɵfac = function NguTileComponent_Factory(t) {\n    return new (t || NguTileComponent)();\n  };\n  NguTileComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NguTileComponent,\n    selectors: [[\"ngu-tile\"]],\n    hostVars: 2,\n    hostBindings: function NguTileComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"item\", ctx.classes);\n      }\n    },\n    ngContentSelectors: _c5,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"tile\"]],\n    template: function NguTileComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{padding:10px;box-sizing:border-box}.tile[_ngcontent-%COMP%]{box-shadow:0 2px 5px #00000029,0 2px 10px #0000001f}\"]\n  });\n  return NguTileComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NguCarouselModule = /*#__PURE__*/(() => {\n  class NguCarouselModule {}\n  NguCarouselModule.ɵfac = function NguCarouselModule_Factory(t) {\n    return new (t || NguCarouselModule)();\n  };\n  NguCarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NguCarouselModule\n  });\n  NguCarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return NguCarouselModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of carousel\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NguCarousel, NguCarouselConfig, NguCarouselDefDirective, NguCarouselItemDirective, NguCarouselModule, NguCarouselNextDirective, NguCarouselOutlet, NguCarouselPointDirective, NguCarouselPrevDirective, NguCarouselStore, NguItemComponent, NguTileComponent };\n//# sourceMappingURL=ngu-carousel.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}