{"ast":null,"code":"import { ElementRef } from \"@angular/core\";\nimport * as i0 from \"@angular/core\";\nexport let ScrollToDirective = /*#__PURE__*/(() => {\n  class ScrollToDirective {\n    constructor(elmID, el) {\n      this.elmID = elmID;\n      this.el = el;\n    }\n    ngOnInit() {}\n    currentYPosition() {\n      // Firefox, Chrome, Opera, Safari\n      if (self.pageYOffset) return self.pageYOffset;\n      // Internet Explorer 6 - standards mode\n      if (document.documentElement && document.documentElement.scrollTop) return document.documentElement.scrollTop;\n      // Internet Explorer 6, 7 and 8\n      if (document.body.scrollTop) return document.body.scrollTop;\n      return 0;\n    }\n    elmYPosition(eID) {\n      var elm = document.getElementById(eID);\n      var y = elm.offsetTop;\n      var node = elm;\n      while (node.offsetParent && node.offsetParent != document.body) {\n        node = node.offsetParent;\n        y += node.offsetTop;\n      }\n      return y;\n    }\n    smoothScroll(e) {\n      // console.log(e);\n      e.preventDefault();\n      if (!this.elmID) return;\n      var startY = this.currentYPosition();\n      var stopY = this.elmYPosition(this.elmID);\n      var distance = stopY > startY ? stopY - startY : startY - stopY;\n      if (distance < 100) {\n        scrollTo(0, stopY);\n        return;\n      }\n      var speed = Math.round(distance / 50);\n      if (speed >= 20) speed = 20;\n      var step = Math.round(distance / 25);\n      var leapY = stopY > startY ? startY + step : startY - step;\n      var timer = 0;\n      if (stopY > startY) {\n        for (var i = startY; i < stopY; i += step) {\n          setTimeout(\"window.scrollTo(0, \" + leapY + \")\", timer * speed);\n          leapY += step;\n          if (leapY > stopY) leapY = stopY;\n          timer++;\n        }\n        return;\n      }\n      for (var i = startY; i > stopY; i -= step) {\n        setTimeout(\"window.scrollTo(0, \" + leapY + \")\", timer * speed);\n        leapY -= step;\n        if (leapY < stopY) leapY = stopY;\n        timer++;\n      }\n      return false;\n    }\n  }\n  ScrollToDirective.ɵfac = function ScrollToDirective_Factory(t) {\n    return new (t || ScrollToDirective)(i0.ɵɵinjectAttribute(\"scrollTo\"), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  ScrollToDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: ScrollToDirective,\n    selectors: [[\"\", \"scrollTo\", \"\"]],\n    hostBindings: function ScrollToDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function ScrollToDirective_click_HostBindingHandler($event) {\n          return ctx.smoothScroll($event);\n        });\n      }\n    }\n  });\n  return ScrollToDirective;\n})();","map":null,"metadata":{},"sourceType":"module"}